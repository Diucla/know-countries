{"version":3,"sources":["ng://ngx-export-as/lib/export-as.service.ts","ng://ngx-export-as/lib/export-as.module.ts"],"names":["window","html2canvas","ExportAsService","prototype","get","config","func","type","toUpperCase","this","Observable","create","observer","error","save","fileName","download","contentToBlob","content","arr","split","mime","match","bstr","atob","n","length","u8arr","Uint8Array","charCodeAt","next","Blob","complete","removeFileTypeFromBase64","fileContent","Symbol","replace","addFileTypeToBase64","fileMime","downloadFromDataURL","dataURL","_this","subscribe","blob","downloadFromBlob","url","URL","createObjectURL","navigator","msSaveOrOpenBlob","element","document","createElement","setAttribute","style","display","body","appendChild","href","click","removeChild","getPDF","options","filename","getElementById","elementId","pdf","html2pdf","set","from","pdfCallbackFn","applyPdfCallbackFn","outputPdf","then","data","toPdf","pdfRef","getPNG","canvas","imgData","toDataURL","err","getCSV","csv","rows","querySelectorAll","index","row","cols","colIndex","col","push","innerText","join","csvContent","btoa","getTXT","nameFrags","getXLS","ws3","XLSX.utils","table_to_sheet","wb","book_new","book_append_sheet","xlsContent","XLSX.write","getXLSX","getDOCX","outerHTML","converted","htmlDocx.asBlob","reader_1","FileReader","onloadend","base64data","result","readAsDataURL","getDOC","getJSON","headers","table","cells","innerHTML","toLowerCase","i","tableRow","rowData","j","jsonString","JSON","stringify","dataStr","getXML","xml","tritem","getElementsByTagName","celldata","textContent","m","base64","unescape","encodeURIComponent","Injectable","ExportAsModule","NgModule","args","providers"],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\n\r\nimport { ExportAsConfig } from './export-as-config.model';\r\n\r\nimport html2canvas from 'html2canvas';\r\nimport * as XLSX from 'xlsx';\r\nimport * as htmlDocx from 'html-docx-js/dist/html-docx';\r\nimport html2pdf from 'html2pdf.js';\r\n\r\nwindow['html2canvas'] = html2canvas;\r\n\r\n@Injectable()\r\nexport class ExportAsService {\r\n\r\n  constructor() { }\r\n\r\n  /**\r\n   * Main base64 get method, it will return the file as base64 string\r\n   * @param config your config\r\n   */\r\n  get(config: ExportAsConfig): Observable<string | null> {\r\n    // structure method name dynamically by type\r\n    const func = 'get' + config.type.toUpperCase();\r\n    // if type supported execute and return\r\n    if (this[func]) {\r\n      return this[func](config);\r\n    }\r\n\r\n    // throw error for unsupported formats\r\n    return Observable.create((observer) => { observer.error('Export type is not supported.'); });\r\n  }\r\n\r\n  /**\r\n   * Save exported file in old javascript way\r\n   * @param config your custom config\r\n   * @param fileName Name of the file to be saved as\r\n   */\r\n  save(config: ExportAsConfig, fileName: string): Observable<string | null> {\r\n    // set download\r\n    config.download = true;\r\n    // get file name with type\r\n    config.fileName = fileName + '.' + config.type;\r\n    return this.get(config);\r\n  }\r\n\r\n  /**\r\n   * Converts content string to blob object\r\n   * @param content string to be converted\r\n   */\r\n  contentToBlob(content: string): Observable<Blob> {\r\n    return Observable.create((observer) => {\r\n      // get content string and extract mime type\r\n      const arr = content.split(','), mime = arr[0].match(/:(.*?);/)[1],\r\n        bstr = atob(arr[1]);\r\n      let n = bstr.length;\r\n      const u8arr = new Uint8Array(n);\r\n      while (n--) {\r\n        u8arr[n] = bstr.charCodeAt(n);\r\n      }\r\n      observer.next(new Blob([u8arr], { type: mime }));\r\n      observer.complete();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Removes base64 file type from a string like \"data:text/csv;base64,\"\r\n   * @param fileContent the base64 string to remove the type from\r\n   */\r\n  removeFileTypeFromBase64(fileContent: string): string {\r\n    const re = /^data:[^]*;base64,/g;\r\n    const newContent: string = re[Symbol.replace](fileContent, '');\r\n    return newContent;\r\n  }\r\n\r\n  /**\r\n   * Structure the base64 file content with the file type string\r\n   * @param fileContent file content\r\n   * @param fileMime file mime type \"text/csv\"\r\n   */\r\n  addFileTypeToBase64(fileContent: string, fileMime: string): string {\r\n    return `data:${fileMime};base64,${fileContent}`;\r\n  }\r\n\r\n  /**\r\n   * create downloadable file from dataURL\r\n   * @param fileName downloadable file name\r\n   * @param dataURL file content as dataURL\r\n   */\r\n  downloadFromDataURL(fileName: string, dataURL: string): void {\r\n    // create blob\r\n    this.contentToBlob(dataURL).subscribe(blob => {\r\n      // download the blob\r\n      this.downloadFromBlob(blob, fileName);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Downloads the blob object as a file\r\n   * @param blob file object as blob\r\n   * @param fileName downloadable file name\r\n   */\r\n  downloadFromBlob(blob: Blob, fileName: string) {\r\n    // get object url\r\n    const url = window.URL.createObjectURL(blob);\r\n    // check for microsoft internet explorer\r\n    if (window.navigator && window.navigator.msSaveOrOpenBlob) {\r\n      // use IE download or open if the user using IE\r\n      window.navigator.msSaveOrOpenBlob(blob, fileName);\r\n    } else {\r\n      // if not using IE then create link element\r\n      const element = document.createElement('a');\r\n      // set download attr with file name\r\n      element.setAttribute('download', fileName);\r\n      // set the element as hidden\r\n      element.style.display = 'none';\r\n      // append the body\r\n      document.body.appendChild(element);\r\n      // set href attr\r\n      element.href = url;\r\n      // click on it to start downloading\r\n      element.click();\r\n      // remove the link from the dom\r\n      document.body.removeChild(element);\r\n    }\r\n  }\r\n\r\n  private getPDF(config: ExportAsConfig): Observable<string | null> {\r\n    return Observable.create((observer) => {\r\n      if (!config.options) {\r\n        config.options = {};\r\n      }\r\n      config.options.filename = config.fileName;\r\n      const element: HTMLElement = document.getElementById(config.elementId);\r\n      const pdf = html2pdf().set(config.options).from(element, 'element');\r\n\r\n      const download = config.download;\r\n      const pdfCallbackFn = config.options.pdfCallbackFn;\r\n      if (download) {\r\n        if (pdfCallbackFn) {\r\n          this.applyPdfCallbackFn(pdf, pdfCallbackFn).save();\r\n        } else {\r\n          pdf.save();\r\n        }\r\n        observer.next();\r\n        observer.complete();\r\n      } else {\r\n        if (pdfCallbackFn) {\r\n          this.applyPdfCallbackFn(pdf, pdfCallbackFn).outputPdf('datauristring').then(data => {\r\n            observer.next(data);\r\n            observer.complete();\r\n          });\r\n        } else {\r\n          pdf.outputPdf('datauristring').then(data => {\r\n            observer.next(data);\r\n            observer.complete();\r\n          });\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  private applyPdfCallbackFn(pdf, pdfCallbackFn) {\r\n    return pdf.toPdf().get('pdf').then((pdfRef) => {\r\n      pdfCallbackFn(pdfRef);\r\n    });\r\n  }\r\n\r\n  private getPNG(config: ExportAsConfig): Observable<string | null> {\r\n    return Observable.create((observer) => {\r\n      const element: HTMLElement = document.getElementById(config.elementId);\r\n      html2canvas(element, config.options).then((canvas) => {\r\n        const imgData = canvas.toDataURL('image/PNG');\r\n        if (config.type === 'png' && config.download) {\r\n          this.downloadFromDataURL(config.fileName, imgData);\r\n          observer.next();\r\n        } else {\r\n          observer.next(imgData);\r\n        }\r\n        observer.complete();\r\n      }, err => {\r\n        observer.error(err);\r\n      });\r\n    });\r\n  }\r\n\r\n  private getCSV(config: ExportAsConfig): Observable<string | null> {\r\n    return Observable.create((observer) => {\r\n      const element: HTMLElement = document.getElementById(config.elementId);\r\n      const csv = [];\r\n      const rows: any = element.querySelectorAll('table tr');\r\n      for (let index = 0; index < rows.length; index++) {\r\n        const rowElement = rows[index];\r\n        const row = [];\r\n        const cols = rowElement.querySelectorAll('td, th');\r\n        for (let colIndex = 0; colIndex < cols.length; colIndex++) {\r\n          const col = cols[colIndex];\r\n          row.push(col.innerText);\r\n        }\r\n        csv.push(row.join(','));\r\n      }\r\n      const csvContent = 'data:text/csv;base64,' + this.btoa(csv.join('\\n'));\r\n      if (config.download) {\r\n        this.downloadFromDataURL(config.fileName, csvContent);\r\n        observer.next();\r\n      } else {\r\n        observer.next(csvContent);\r\n      }\r\n      observer.complete();\r\n    });\r\n  }\r\n\r\n  private getTXT(config: ExportAsConfig): Observable<string | null> {\r\n    const nameFrags = config.fileName.split('.');\r\n    config.fileName = `${nameFrags[0]}.txt`;\r\n    return this.getCSV(config);\r\n  }\r\n\r\n  private getXLS(config: ExportAsConfig): Observable<string | null> {\r\n    return Observable.create((observer) => {\r\n\r\n      const element: HTMLElement = document.getElementById(config.elementId);\r\n      const ws3 = XLSX.utils.table_to_sheet(element, config.options);\r\n      const wb = XLSX.utils.book_new();\r\n      XLSX.utils.book_append_sheet(wb, ws3, config.fileName);\r\n      const out = XLSX.write(wb, { type: 'base64' });\r\n      const xlsContent = 'data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,' + out;\r\n      if (config.download) {\r\n        this.downloadFromDataURL(config.fileName, xlsContent);\r\n        observer.next();\r\n      } else {\r\n        observer.next(xlsContent);\r\n      }\r\n      observer.complete();\r\n    });\r\n  }\r\n\r\n  private getXLSX(config: ExportAsConfig): Observable<string | null> {\r\n    return this.getXLS(config);\r\n  }\r\n\r\n  private getDOCX(config: ExportAsConfig): Observable<string | null> {\r\n    return Observable.create((observer) => {\r\n      const contentDocument: string = document.getElementById(config.elementId).outerHTML;\r\n      const content = '<!DOCTYPE html>' + contentDocument;\r\n      const converted = htmlDocx.asBlob(content, config.options);\r\n      if (config.download) {\r\n        this.downloadFromBlob(converted, config.fileName);\r\n        observer.next();\r\n        observer.complete();\r\n      } else {\r\n        const reader = new FileReader();\r\n        reader.onloadend = () => {\r\n          const base64data = reader.result;\r\n          observer.next(base64data);\r\n          observer.complete();\r\n        };\r\n        reader.readAsDataURL(converted);\r\n      }\r\n    });\r\n  }\r\n\r\n  private getDOC(config: ExportAsConfig): Observable<string | null> {\r\n    return this.getDOCX(config);\r\n  }\r\n\r\n  private getJSON(config: ExportAsConfig): Observable<any[] | null> {\r\n    return Observable.create((observer) => {\r\n      const data = []; // first row needs to be headers\r\n      const headers = [];\r\n      const table = <HTMLTableElement>document.getElementById(config.elementId);\r\n      for (let index = 0; index < table.rows[0].cells.length; index++) {\r\n        headers[index] = table.rows[0].cells[index].innerHTML.toLowerCase().replace(/ /gi, '');\r\n      }\r\n      // go through cells\r\n      for (let i = 1; i < table.rows.length; i++) {\r\n        const tableRow = table.rows[i]; const rowData = {};\r\n        for (let j = 0; j < tableRow.cells.length; j++) {\r\n          rowData[headers[j]] = tableRow.cells[j].innerHTML;\r\n        }\r\n        data.push(rowData);\r\n      }\r\n      const jsonString = JSON.stringify(data);\r\n      const jsonBase64 = this.btoa(jsonString);\r\n      const dataStr = 'data:text/json;base64,' + jsonBase64;\r\n      if (config.download) {\r\n        this.downloadFromDataURL(config.fileName, dataStr);\r\n        observer.next();\r\n      } else {\r\n        observer.next(data);\r\n      }\r\n      observer.complete();\r\n    });\r\n  }\r\n\r\n  private getXML(config: ExportAsConfig): Observable<string | null> {\r\n    return Observable.create((observer) => {\r\n      let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?><Root><Classes>';\r\n      const tritem = document.getElementById(config.elementId).getElementsByTagName('tr');\r\n      for (let i = 0; i < tritem.length; i++) {\r\n        const celldata = tritem[i];\r\n        if (celldata.cells.length > 0) {\r\n          xml += '<Class name=\"' + celldata.cells[0].textContent + '\">\\n';\r\n          for (let m = 1; m < celldata.cells.length; ++m) {\r\n            xml += '\\t<data>' + celldata.cells[m].textContent + '</data>\\n';\r\n          }\r\n          xml += '</Class>\\n';\r\n        }\r\n      }\r\n      xml += '</Classes></Root>';\r\n      const base64 = 'data:text/xml;base64,' + this.btoa(xml);\r\n      if (config.download) {\r\n        this.downloadFromDataURL(config.fileName, base64);\r\n        observer.next();\r\n      } else {\r\n        observer.next(base64);\r\n      }\r\n      observer.complete();\r\n    });\r\n  }\r\n\r\n  private btoa(content: string) {\r\n    return btoa(unescape(encodeURIComponent(content)));\r\n  }\r\n\r\n}\r\n","/**\n * angular imports\n */\nimport { NgModule } from '@angular/core';\n\n/**\n * my imports\n */\nimport { ExportAsService } from './export-as.service';\n\n@NgModule({\n  providers: [ExportAsService],\n})\nexport class ExportAsModule { }\n\n\n"]}